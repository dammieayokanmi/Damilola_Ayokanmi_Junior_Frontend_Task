{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('graphql')) : typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'graphql'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['graphql-tag'] = {}, global.tslib, global.graphql));\n})(this, function (exports, tslib, graphql) {\n  'use strict';\n\n  var docCache = new Map();\n  var fragmentSourceMap = new Map();\n  var printFragmentWarnings = true;\n  var experimentalFragmentVariables = false;\n\n  function normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n  }\n\n  function cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n  }\n\n  function processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n      if (fragmentDefinition.kind === 'FragmentDefinition') {\n        var fragmentName = fragmentDefinition.name.value;\n        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n        var sourceKeySet = fragmentSourceMap.get(fragmentName);\n\n        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n          if (printFragmentWarnings) {\n            console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n          }\n        } else if (!sourceKeySet) {\n          fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n        }\n\n        sourceKeySet.add(sourceKey);\n\n        if (!seenKeys.has(sourceKey)) {\n          seenKeys.add(sourceKey);\n          definitions.push(fragmentDefinition);\n        }\n      } else {\n        definitions.push(fragmentDefinition);\n      }\n    });\n    return tslib.__assign(tslib.__assign({}, ast), {\n      definitions: definitions\n    });\n  }\n\n  function stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n      if (node.loc) delete node.loc;\n      Object.keys(node).forEach(function (key) {\n        var value = node[key];\n\n        if (value && typeof value === 'object') {\n          workSet.add(value);\n        }\n      });\n    });\n    var loc = doc.loc;\n\n    if (loc) {\n      delete loc.startToken;\n      delete loc.endToken;\n    }\n\n    return doc;\n  }\n\n  function parseDocument(source) {\n    var cacheKey = normalize(source);\n\n    if (!docCache.has(cacheKey)) {\n      var parsed = graphql.parse(source, {\n        experimentalFragmentVariables: experimentalFragmentVariables,\n        allowLegacyFragmentVariables: experimentalFragmentVariables\n      });\n\n      if (!parsed || parsed.kind !== 'Document') {\n        throw new Error('Not a valid GraphQL document.');\n      }\n\n      docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n\n    return docCache.get(cacheKey);\n  }\n\n  function gql(literals) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (typeof literals === 'string') {\n      literals = [literals];\n    }\n\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n      if (arg && arg.kind === 'Document') {\n        result += arg.loc.source.body;\n      } else {\n        result += arg;\n      }\n\n      result += literals[i + 1];\n    });\n    return parseDocument(result);\n  }\n\n  function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n  }\n\n  function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n  }\n\n  function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n  }\n\n  function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n  }\n\n  var extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n  };\n\n  (function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n  })(gql || (gql = {}));\n\n  gql[\"default\"] = gql;\n  var gql$1 = gql;\n  exports.default = gql$1;\n  exports.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n  exports.disableFragmentWarnings = disableFragmentWarnings;\n  exports.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\n  exports.gql = gql;\n  exports.resetCaches = resetCaches;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":";;;;;EASA,IAAMA,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;EAGA,IAAMC,iBAAiB,GAAG,IAAID,GAAJ,EAA1B;EAEA,IAAIE,qBAAqB,GAAG,IAA5B;EACA,IAAIC,6BAA6B,GAAG,KAApC;;EAIA,SAASC,SAAT,CAAmBC,MAAnB,EAAiC;IAC/B,OAAOA,MAAM,CAACC,OAAP,CAAe,SAAf,EAA0B,GAA1B,EAA+BC,IAA/B,EAAP;EACD;;EAED,SAASC,eAAT,CAAyBC,GAAzB,EAAsC;IACpC,OAAOL,SAAS,CAACK,GAAG,CAACC,MAAJ,CAAWC,IAAX,CAAgBC,SAAhB,CAA0BH,GAAG,CAACI,KAA9B,EAAqCJ,GAAG,CAACK,GAAzC,CAAD,CAAhB;EACD;;EAKD,SAASC,gBAAT,CAA0BC,GAA1B,EAA2C;IACzC,IAAMC,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;IACA,IAAMC,WAAW,GAAqB,EAAtC;IAEAH,GAAG,CAACG,WAAJ,CAAgBC,OAAhB,CAAwB,8BAAkB;MACxC,IAAIC,kBAAkB,CAACC,IAAnB,KAA4B,oBAAhC,EAAsD;QACpD,IAAIC,YAAY,GAAGF,kBAAkB,CAACG,IAAnB,CAAwBC,KAA3C;QACA,IAAIC,SAAS,GAAGlB,eAAe,CAACa,kBAAkB,CAACZ,GAApB,CAA/B;QAGA,IAAIkB,YAAY,GAAG1B,iBAAiB,CAAC2B,GAAlB,CAAsBL,YAAtB,CAAnB;;QACA,IAAII,YAAY,IAAI,CAACA,YAAY,CAACE,GAAb,CAAiBH,SAAjB,CAArB,EAAkD;UAGhD,IAAIxB,qBAAJ,EAA2B;YACzB4B,OAAO,CAACC,IAAR,CAAa,iCAAiCR,YAAjC,GAAgD,oBAAhD,GACT,iGADS,GAET,8EAFJ;UAGD;QACF,CARD,MAQO,IAAI,CAACI,YAAL,EAAmB;UACxB1B,iBAAiB,CAAC+B,GAAlB,CAAsBT,YAAtB,EAAoCI,YAAY,GAAG,IAAIT,GAAJ,EAAnD;QACD;;QAEDS,YAAY,CAACM,GAAb,CAAiBP,SAAjB;;QAEA,IAAI,CAACT,QAAQ,CAACY,GAAT,CAAaH,SAAb,CAAL,EAA8B;UAC5BT,QAAQ,CAACgB,GAAT,CAAaP,SAAb;UACAP,WAAW,CAACe,IAAZ,CAAiBb,kBAAjB;QACD;MACF,CAxBD,MAwBO;QACLF,WAAW,CAACe,IAAZ,CAAiBb,kBAAjB;MACD;IACF,CA5BD;IA8BA,yCACKL,GADL,GACQ;MACNG,WAAW;IADL,CADR;EAID;;EAED,SAASgB,QAAT,CAAkBC,GAAlB,EAAmC;IACjC,IAAMC,OAAO,GAAG,IAAInB,GAAJ,CAA6BkB,GAAG,CAACjB,WAAjC,CAAhB;IAEAkB,OAAO,CAACjB,OAAR,CAAgB,gBAAI;MAClB,IAAIkB,IAAI,CAAC7B,GAAT,EAAc,OAAO6B,IAAI,CAAC7B,GAAZ;MACd8B,MAAM,CAACC,IAAP,CAAYF,IAAZ,EAAkBlB,OAAlB,CAA0B,eAAG;QAC3B,IAAMK,KAAK,GAAGa,IAAI,CAACG,GAAD,CAAlB;;QACA,IAAIhB,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;UACtCY,OAAO,CAACJ,GAAR,CAAYR,KAAZ;QACD;MACF,CALD;IAMD,CARD;IAUA,IAAMhB,GAAG,GAAG2B,GAAG,CAAC3B,GAAhB;;IACA,IAAIA,GAAJ,EAAS;MACP,OAAOA,GAAG,CAACiC,UAAX;MACA,OAAOjC,GAAG,CAACkC,QAAX;IACD;;IAED,OAAOP,GAAP;EACD;;EAED,SAASQ,aAAT,CAAuBlC,MAAvB,EAAqC;IACnC,IAAImC,QAAQ,GAAGzC,SAAS,CAACM,MAAD,CAAxB;;IACA,IAAI,CAACX,QAAQ,CAAC8B,GAAT,CAAagB,QAAb,CAAL,EAA6B;MAC3B,IAAMC,MAAM,GAAGC,cAAMrC,MAANqC,EAAc;QAC3B5C,6BAA6B,+BADF;QAE3B6C,4BAA4B,EAAE7C;MAFH,CAAd4C,CAAf;;MAIA,IAAI,CAACD,MAAD,IAAWA,MAAM,CAACxB,IAAP,KAAgB,UAA/B,EAA2C;QACzC,MAAM,IAAI2B,KAAJ,CAAU,+BAAV,CAAN;MACD;;MACDlD,QAAQ,CAACiC,GAAT,CACEa,QADF,EAIEV,QAAQ,CAACpB,gBAAgB,CAAC+B,MAAD,CAAjB,CAJV;IAMD;;IACD,OAAO/C,QAAQ,CAAC6B,GAAT,CAAaiB,QAAb,CAAP;EACD;;WAGeK,IACdC,UAAoC;IACpC;;SAAA,yCAAc;MAAdC;;;IAGA,IAAI,OAAOD,QAAP,KAAoB,QAAxB,EAAkC;MAChCA,QAAQ,GAAG,CAACA,QAAD,CAAX;IACD;;IAED,IAAIE,MAAM,GAAGF,QAAQ,CAAC,CAAD,CAArB;IAEAC,IAAI,CAAChC,OAAL,CAAa,UAACkC,GAAD,EAAMC,CAAN,EAAO;MAClB,IAAID,GAAG,IAAIA,GAAG,CAAChC,IAAJ,KAAa,UAAxB,EAAoC;QAClC+B,MAAM,IAAIC,GAAG,CAAC7C,GAAJ,CAAQC,MAAR,CAAeC,IAAzB;MACD,CAFD,MAEO;QACL0C,MAAM,IAAIC,GAAV;MACD;;MACDD,MAAM,IAAIF,QAAQ,CAACI,CAAC,GAAG,CAAL,CAAlB;IACD,CAPD;IASA,OAAOX,aAAa,CAACS,MAAD,CAApB;EACD;;WAEeG,cAAW;IACzBzD,QAAQ,CAAC0D,KAAT;IACAxD,iBAAiB,CAACwD,KAAlB;EACD;;WAEeC,0BAAuB;IACrCxD,qBAAqB,GAAG,KAAxB;EACD;;WAEeyD,sCAAmC;IACjDxD,6BAA6B,GAAG,IAAhC;EACD;;WAEeyD,uCAAoC;IAClDzD,6BAA6B,GAAG,KAAhC;EACD;;EAED,IAAM0D,MAAM,GAAG;IACbX,GAAG,KADU;IAEbM,WAAW,aAFE;IAGbE,uBAAuB,yBAHV;IAIbC,mCAAmC,qCAJtB;IAKbC,oCAAoC;EALvB,CAAf;;EAQA,WAAiBE,KAAjB,EAAoB;IAEhBA,YAKED,MAAM,IALR,EACAC,oBAIED,MAAM,YALR,EAEAC,gCAGED,MAAM,wBALR,EAGAC,4CAEED,MAAM,oCALR,EAIAC,6CACED,MAAM,qCALR;EAMH,CARD,EAAiBX,GAAG,KAAHA,GAAG,MAApB;;EAUAA,GAAG,CAAC,SAAD,CAAH,GAAcA,GAAd;EAEA,YAAeA,GAAf","names":["docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","cacheKeyFromLoc","loc","source","body","substring","start","end","processFragments","ast","seenKeys","Set","definitions","forEach","fragmentDefinition","kind","fragmentName","name","value","sourceKey","sourceKeySet","get","has","console","warn","set","add","push","stripLoc","doc","workSet","node","Object","keys","key","startToken","endToken","parseDocument","cacheKey","parsed","parse","allowLegacyFragmentVariables","Error","gql","literals","args","result","arg","i","resetCaches","clear","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","extras","gql_1"],"sources":["/Users/uxxxr/Desktop/projects/me/scandiweb/junior-react-interface/node_modules/graphql-tag/src/index.ts"],"sourcesContent":["import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n"]},"metadata":{},"sourceType":"script"}